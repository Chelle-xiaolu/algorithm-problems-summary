### 动态规划 dynamic programing
1. 动态规划和递归或者分治没有本质性的区别（关键看有无最优的子结构）
  共性：找到重复子问题
  差异性：最优子结构、中途可以淘汰次优解
#### 动态规划关键点
1. 最优子结构 opt[n] = best_of(opt[n-1], opt[n-2]...)
2. 储存中间状态 opt[i]
3. 递推公式（状态转移方程或者dp方程）
例：Fib:opt[i] = opt[i-1] + opt[i-2]
   二维路径:opt[i][j] = opt[i+1][j] + opt[i][j+1]

### 题目练习
1. leetcode【62】不同路径
```
// 思路一：二维数组存储
var uniquePaths = function(m, n) {
  const dp = Array.from(Array(m), ()=>Array(n))
  for(let i = 0; i < m; i++) {
    dp[i][0] = 1
  }
  for(let j = 0; j < n; j++) {
    dp[0][j] = 1
  }
  for(let i = 1; i < m; i++) {
    for(let j = 1; j < n; j++) {
      dp[i][j] = dp[i-1][j] + dp[i][j-1]
    }
  }
  return dp[m-1][n-1]
};
```
```
// 思路二：一维数组存储
const uniquePaths = (m, n) => {
  const dp = Array(n).fill(1)
  for(let i = 1; i < m; i++) {
    for(let j = 1; j < n; j++) {
      dp[j] += dp[j-1]
    }
  }
  return dp[n-1]
}
```
2. leetcode【63】不同路径II
```
var uniquePathsWithObstacles = function(obstacleGrid) {
  if(!obstacleGrid.length){
    return 0
  }
  // 刚开始就遇到障碍物
  if(obstacleGrid[0][0] === 1) {
    return 0
  }
  const m = obstacleGrid.length, n = obstacleGrid[0].length
  const dp = Array.from(Array(m), ()=> Array(n))
  dp[0][0]=1
  for(let i = 1; i < m; i++) {
    // 边界值前一个走不通或者遇到障碍物都是直接0
    dp[i][0] = dp[i-1][0] === 0 || obstacleGrid[i][0] === 1 ? 0 : 1
  }
  for(let j = 1; j < n; j++) {
    // 边界值前一个走不通或者遇到障碍物都是直接0
    dp[0][j] = dp[0][j-1] === 0 || obstacleGrid[0][j] === 1 ? 0 : 1
  }
  for(let i = 1; i < m; i++) {
    for(let j = 1; j < n; j++) {
      dp[i][j] = obstacleGrid[i][j] === 1 ? 0 : dp[i-1][j]+dp[i][j-1]
    }
  }
  return dp[m-1][n-1]
};
```